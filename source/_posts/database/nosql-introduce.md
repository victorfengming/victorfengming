---
title: "Nosql简介 Redis，Memchche,MongoDb的区别"
cover: "/img/lynk/0.jpg"
date:       2019-09-27
tags:
	- Linux
	- deepin
	- database
	- nosql
---

<style>
      h4{
        line-height: 30px;
        font-size: 20px;
        }
</style>

<div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown">
    <h2 id="本篇文章主要介绍nosql的一些东西以及nosql中比较火的三个数据库redismemchachemongodb和他们之间的区别以下是本文章的阅读目录">本篇文章主要介绍Nosql的一些东西，以及Nosql中比较火的三个数据库Redis、Memchache、MongoDb和他们之间的区别。以下是本文章的阅读目录</h2>
<!-- <h3 id="一nosql介绍">一、Nosql介绍</h3> -->
<p>1.<a href="#item1">Nosql简介</a><br>
2.<a href="#item2">Nosql的特点和关系型数据库的区别</a><br>
3.<a href="#item3">Redis，Memcache，MongoDb的特点与区别</a><br>
4<a href="#item4">.参考文章</a><br>
<br></p>
<h1 id="nosql介绍"><span id="item1">Nosql介绍</span></h1>
<h4 id="nosql的全称是not-only-sql这个概念早起就有人提出在09年的时候比较火nosql指的是非关系型数据库而我们常用的都是关系型数据库就像我们常用的mysqlsqlserver一样这些数据库一般用来存储重要信息应对普通的业务是没有问题的但是随着互联网的高速发展传统的关系型数据库在应付超大规模超大流量以及高并发的时候力不从心而就在这个时候nosql得到的告诉的发展">Nosql的全称是Not Only Sql，这个概念早起就有人提出，在09年的时候比较火。Nosql指的是非关系型数据库，而我们常用的都是关系型数据库。就像我们常用的mysql，sqlserver一样，这些数据库一般用来存储重要信息，应对普通的业务是没有问题的。但是，随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心。而就在这个时候，Nosql得到的告诉的发展。</h4>
<p><br></p>
<h1 id="nosql和关系型数据库的区别"><span id="item2">Nosql和关系型数据库的区别</span></h1>
<h3 id="存储方式">1.存储方式</h3>
<h4 id="关系型数据库是表格式的因此存储在表的行和列中他们之间很容易关联协作存储提取数据很方便而nosql数据库则与其相反他是大块的组合在一起通常存储在数据集中就像文档键值对或者图结构">　　关系型数据库是表格式的，因此存储在表的行和列中。他们之间很容易关联协作存储，提取数据很方便。而Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中，就像文档、键值对或者图结构。</h4>
<p><br></p>
<h3 id="存储结构">2.存储结构</h3>
<h4 id="关系型数据库对应的是结构化数据数据表都预先定义了结构列的定义结构描述了数据的形式和内容这一点对数据建模至关重要虽然预定义结构带来了可靠性和稳定性但是修改这些数据比较困难而nosql数据库基于动态结构使用与非结构化数据因为nosql数据库是动态结构可以很容易适应数据类型和结构的变化">　　关系型数据库对应的是结构化数据，数据表都预先定义了结构（列的定义），结构描述了数据的形式和内容。这一点对数据建模至关重要，虽然预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难。而Nosql数据库基于动态结构，使用与非结构化数据。因为Nosql数据库是动态结构，可以很容易适应数据类型和结构的变化。</h4>
<p><br></p>
<h3 id="存储规范">3.存储规范</h3>
<h4 id="关系型数据库的数据存储为了更高的规范性把数据分割为最小的关系表以避免重复获得精简的空间利用虽然管理起来很清晰但是单个操作设计到多张表的时候数据管理就显得有点麻烦而nosql数据存储在平面数据集中数据经常可能会重复单个数据库很少被分隔开而是存储成了一个整体这样整块数据更加便于读写">　　关系型数据库的数据存储为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用。虽然管理起来很清晰，但是单个操作设计到多张表的时候，数据管理就显得有点麻烦。而Nosql数据存储在平面数据集中，数据经常可能会重复。单个数据库很少被分隔开，而是存储成了一个整体，这样整块数据更加便于读写</h4>
<p><br></p>
<h3 id="存储扩展">4.存储扩展</h3>
<h4 id="这可能是两者之间最大的区别关系型数据库是纵向扩展也就是说想要提高处理能力要使用速度更快的计算机因为数据存储在关系表中操作的性能瓶颈可能涉及到多个表需要通过提升计算机性能来克服虽然有很大的扩展空间但是最终会达到纵向扩展的上限而nosql数据库是横向扩展的它的存储天然就是分布式的可以通过给资源池添加更多的普通数据库服务器来分担负载">　　这可能是两者之间最大的区别，关系型数据库是纵向扩展，也就是说想要提高处理能力，要使用速度更快的计算机。因为数据存储在关系表中，操作的性能瓶颈可能涉及到多个表，需要通过提升计算机性能来克服。虽然有很大的扩展空间，但是最终会达到纵向扩展的上限。而Nosql数据库是横向扩展的，它的存储天然就是分布式的，可以通过给资源池添加更多的普通数据库服务器来分担负载。</h4>
<p><br></p>
<h3 id="查询方式">5.查询方式</h3>
<h4 id="关系型数据库通过结构化查询语言来操作数据库就是我们通常说的sqlsql支持数据库curd操作的功能非常强大是业界的标准用法而nosql查询以块为单元操作数据使用的是非结构化查询语言unql它是没有标准的关系型数据库表中主键的概念对应nosql中存储文档的id关系型数据库使用预定义优化方式比如索引来加快查询操作而nosql更简单更精确的数据访问模式">　　关系型数据库通过结构化查询语言来操作数据库（就是我们通常说的SQL）。SQL支持数据库CURD操作的功能非常强大，是业界的标准用法。而Nosql查询以块为单元操作数据，使用的是非结构化查询语言（UnQl），它是没有标准的。关系型数据库表中主键的概念对应Nosql中存储文档的ID。关系型数据库使用预定义优化方式（比如索引）来加快查询操作，而Nosql更简单更精确的数据访问模式。</h4>
<p><br></p>
<h3 id="事务">6.事务</h3>
<h4 id="关系型数据库遵循acid规则原子性atomicity一致性consistency隔离性isolation持久性durability而nosql数据库遵循base原则基本可用basically-availble软柔性事务soft-state-最终一致性eventual-consistency由于关系型数据库的数据强一致性所以对事务的支持很好关系型数据库支持对事务原子性细粒度控制并且易于回滚事务而nosql数据库是在cap一致性可用性分区容忍度中任选两项因为基于节点的分布式系统中很难全部满足所以对事务的支持不是很好虽然也可以使用事务但是并不是nosql的闪光点">　　关系型数据库遵循ACID规则（原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)），而Nosql数据库遵循BASE原则（基本可用（Basically Availble）、软/柔性事务（Soft-state ）、最终一致性（Eventual Consistency））。由于关系型数据库的数据强一致性，所以对事务的支持很好。关系型数据库支持对事务原子性细粒度控制，并且易于回滚事务。而Nosql数据库是在CAP（一致性、可用性、分区容忍度）中任选两项，因为基于节点的分布式系统中，很难全部满足，所以对事务的支持不是很好，虽然也可以使用事务，但是并不是Nosql的闪光点。</h4>
<p><br></p>
<h3 id="性能">7.性能</h3>
<h4 id="关系型数据库为了维护数据的一致性付出了巨大的代价读写性能比较差在面对高并发读写性能非常差面对海量数据的时候效率非常低而nosql存储的格式都是key-value类型的并且存储在内存中非常容易存储而且对于数据的-一致性是-弱要求nosql无需sql的解析提高了读写性能">　　关系型数据库为了维护数据的一致性付出了巨大的代价，读写性能比较差。在面对高并发读写性能非常差，面对海量数据的时候效率非常低。而Nosql存储的格式都是key-value类型的，并且存储在内存中，非常容易存储，而且对于数据的 一致性是 弱要求。Nosql无需sql的解析，提高了读写性能。</h4>
<p><br></p>
<h3 id="授权方式">8.授权方式</h3>
<h4 id="关系型数据库通常有sql-servermysqloracle主流的nosql数据库有redismemcachemongodb大多数的关系型数据库都是付费的并且价格昂贵成本较大而nosql数据库通常都是开源的">　　关系型数据库通常有SQL Server，Mysql，Oracle。主流的Nosql数据库有redis，memcache，MongoDb。大多数的关系型数据库都是付费的并且价格昂贵，成本较大，而Nosql数据库通常都是开源的。</h4>
<p><br></p>
<h1 id="redismemcachemongodb的特点与区别"><span id="item3">Redis，Memcache，MongoDb的特点与区别</span></h1>
<p><br></p>
<h2 id="redis">Redis</h2>
<h3 id="优点">优点</h3>
<h4 id="支持多种数据结构如-string字符串-list双向链表dicthash表set集合zset排序sethyperloglog基数估算-2.支持持久化操作可以进行aof及rdb数据持久化到磁盘从而进行数据备份或数据恢复等操作较好的防止数据丢失的手段-3.支持通过replication进行数据复制通过master-slave机制可以实时进行数据的同步复制支持多级复制和增量复制master-slave机制是redis进行ha的重要手段-4.单线程请求所有命令串行执行并发情况下不需要考虑数据一致性问题-5.支持pubsub消息订阅机制可以用来进行消息订阅与通知-6.支持简单的事务需求但业界使用场景很少并不成熟">1.支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）<br>2.支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失　　的手段。<br>3.支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。<br>4.单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。<br>5.支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。<br>6.支持简单的事务需求，但业界使用场景很少，并不成熟。</h4>
<h3 id="缺点">缺点</h3>
<h4 id="redis只能使用单线程性能受限于cpu性能故单实例cpu最高才可能达到5-6wqps每秒取决于数据结构数据大小以及服务器硬件性能日常环境中qps高峰大约在1-2w左右-2.支持简单的事务需求但业界使用场景很少并不成熟既是优点也是缺点-3.redis在string类型上会消耗较多内存可以使用dicthash表压缩存储以降低内存耗用">1.Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。<br>2.支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。<br>3.Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。</h4>
<p><br></p>
<h2 id="memcache">Memcache</h2>
<h3 id="优点-1">优点</h3>
<h4 id="memcached可以利用多核优势单实例吞吐量极高可以达到几十万qps取决于keyvalue的字节大小以及服务器硬件性能日常环境中qps高峰大约在4-6w左右适用于最大程度扛量-2.支持直接配置为session-handle">1.Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。<br>2.支持直接配置为session handle。</h4>
<h3 id="缺点-1">缺点</h3>
<h4 id="只支持简单的keyvalue数据结构不像redis可以支持丰富的数据类型-2.无法进行持久化数据不能备份只能用于缓存使用且重启后数据全部丢失-3.无法进行数据同步不能将mc中的数据迁移到其他mc实例中-4.memcached内存分配采用slab-allocation机制管理内存value大小分布差异较大时会造成内存利用率降低并引发低利用率时依然出现踢出等问题需要用户注重value设计">1只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。<br>2.无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。<br>3.无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。<br>4.Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。</h4>
<p><br></p>
<h2 id="mongodb">MongoDB</h2>
<h3 id="优点-2">优点</h3>
<h4 id="更高的写负载mongodb拥有更高的插入速度-2.处理很大的规模的单表当数据表太大的时候可以很容易的分割表-3.高可用性设置m-s不仅方便而且很快mongodb还可以快速安全及自动化的实现节点数据中心故障转移-4.快速的查询mongodb支持二维空间索引比如管道因此可以快速及精确的从指定位置获取数据mongodb在启动后会将数据库中的数据以文件映射的方式加载到内存中如果内存资源相当丰富的话这将极大地提高数据库的查询速度-5.非结构化数据的爆发增长增加列在有些情况下可能锁定整个数据库或者增加负载从而导致性能下降由于mongodb的弱数据结构模式添加1个新字段不会对旧表格有任何影响整个过程会非常快速">1.更高的写负载，MongoDB拥有更高的插入速度。<br>2.处理很大的规模的单表，当数据表太大的时候可以很容易的分割表。<br>3.高可用性，设置M-S不仅方便而且很快，MongoDB还可以快速、安全及自动化的实现节点（数据中心）故障转移。<br>4.快速的查询，MongoDB支持二维空间索引，比如管道，因此可以快速及精确的从指定位置获取数据。MongoDB在启动后会将数据库中的数据以文件映射的方式加载到内存中。如果内存资源相当丰富的话，这将极大地提高数据库的查询速度。<br>5.非结构化数据的爆发增长，增加列在有些情况下可能锁定整个数据库，或者增加负载从而导致性能下降，由于MongoDB的弱数据结构模式，添加1个新字段不会对旧表格有任何影响，整个过程会非常快速。</h4>
<h3 id="缺点-2">缺点</h3>
<h4 id="不支持事务-2.mongodb占用空间过大-3.mongodb没有成熟的维护工具">1.不支持事务。<br>2.MongoDB占用空间过大 。<br>3.MongoDB没有成熟的维护工具。</h4>
<p><br></p>
<h2 id="redismemcache和mongodb的区别">Redis、Memcache和MongoDB的区别</h2>
<h3 id="性能-1">1.性能</h3>
<h4 id="三者的性能都比较高总的来讲memcache和redis差不多要高于mongodb">三者的性能都比较高，总的来讲：Memcache和Redis差不多，要高于MongoDB。</h4>
<h3 id="便利性">2.便利性</h3>
<h4 id="memcache数据结构单一-redis丰富一些数据操作方面redis更好一些较少的网络io次数-mongodb支持丰富的数据表达索引最类似关系型数据库支持的查询语言非常丰富">memcache数据结构单一。<br>redis丰富一些，数据操作方面，redis更好一些，较少的网络IO次数。<br>mongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。</h4>
<h3 id="存储空间">3,存储空间</h3>
<h4 id="redis在2.0版本后增加了自己的vm特性突破物理内存的限制可以对key-value设置过期时间类似memcache-memcache可以修改最大可用内存采用lru算法-mongodb适合大数据量的存储依赖操作系统vm做内存管理吃内存也比较厉害服务不要和别的服务在一起">redis在2.0版本后增加了自己的VM特性，突破物理内存的限制；可以对key value设置过期时间（类似memcache）。<br>memcache可以修改最大可用内存,采用LRU算法。<br>mongoDB适合大数据量的存储，依赖操作系统VM做内存管理，吃内存也比较厉害，服务不要和别的服务在一起。</h4>
<h3 id="可用性">4.可用性</h3>
<h4 id="redis依赖客户端来实现分布式读写主从复制时每次从节点重新连接主节点都要依赖整个快照无增量复制因性能和效率问题所以单点问题比较复杂不支持自动sharding需要依赖程序设定一致hash-机制一种替代方案是不用redis本身的复制机制采用自己做主动复制多份存储或者改成增量复制的方式需要自己实现一致性问题和性能的权衡-memcache本身没有数据冗余机制也没必要对于故障预防采用依赖成熟的hash或者环状的算法解决单点故障引起的抖动问题-mongodb支持master-slavereplicaset内部采用paxos选举算法自动故障恢复auto-sharding机制对客户端屏蔽了故障转移和切分机制">redis，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制，因性能和效率问题，所以单点问题比较复杂；不支持自动sharding,需要依赖程序设定一致hash 机制。一种替代方案是，不用redis本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡。<br>Memcache本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的hash或者环状的算法，解决单点故障引起的抖动问题。<br>mongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。</h4>
<h3 id="可靠性">5.可靠性</h3>
<h4 id="redis支持快照aof依赖快照进行持久化aof增强了可靠性的同时对性能有所影响-memcache不支持通常用在做缓存提升性能-mongodb从1.8版本开始采用binlog方式支持持久化的可靠性">redis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响。<br>memcache不支持，通常用在做缓存,提升性能。<br>MongoDB从1.8版本开始采用binlog方式支持持久化的可靠性。</h4>
<h3 id="一致性">6.一致性</h3>
<h4 id="memcache-在并发场景下用cas保证一致性-redis事务支持比较弱只能保证事务中的每个操作连续执行-mongodb不支持事务">Memcache 在并发场景下，用cas保证一致性。<br>redis事务支持比较弱，只能保证事务中的每个操作连续执行。<br>mongoDB不支持事务。</h4>
<h3 id="数据分析">7.数据分析</h3>
<h4 id="mongodb内置了数据分析的功能mapreduce其他两者不支持">mongoDB内置了数据分析的功能(mapreduce),其他两者不支持。</h4>
<h3 id="应用场景">8.应用场景</h3>
<h4 id="redis数据量较小的更性能操作和运算上-memcache用于在动态系统中减少数据库负载提升性能做缓存提高性能适合读多写少对于数据量比较大可以采用sharding-mongodb主要解决海量数据的访问效率问题">redis：数据量较小的更性能操作和运算上。<br>memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）。<br><a href="MongoDB:主要解决海量数据的访问效率问题。####" class="uri">MongoDB:主要解决海量数据的访问效率问题。####</a></h4>
<p><br></p>
<h1 id="参考文章"><span id="item4">参考文章</span></h1>
<h4 id="redismemcache和mongodb的区别-1"><a href="http://www.cnblogs.com/tuyile006/p/6382062.html">Redis、Memcache和MongoDB的区别</a></h4>

</div>