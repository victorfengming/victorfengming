---
title: "从头到尾彻底理解贪心算法"
cover: "/img/lynk/71.jpg"
date:       2011-12-05
tags:
	- algorithm

---



 一.贪心算法

1.总是做出局部最优解，寄希望这样的选择能导致全局最优解，即每一步都做出当时看起来最佳的选择，

2.贪心算法并不保证得到最优解，但对很多问题可以求得最优解

\3. 对于一个问题，可能有多种贪心策略

4.贪心算法通常自顶向下地设计，做出一个选择，然后求解剩下的那个子问题，而不是自底向上地求解更多的子问题然后再做出选择

5.一般步骤：

![img](1341696-20180719162133749-1241814273.png)

6.证明一个贪心算法能否求解一个最优化问题的两个关键要素

（1）贪心选择性质：每步的贪心选择都是当时的最优解，贪心算法进行选择时可能依赖之前作出的选择，但不依赖任何将来的选择或是子问题的解，而且第一次选择之前不求解任何子问题

（2）最优子结构：原问题最优解包含其子问题的最优解

 

二.活动选择问题

1.问题描述：

![img](1341696-20180719154303940-1789264632.png)

2.最优子结构：可证明：原问题最优解必然包含子问题的最优解

3.一种贪心选择：选择一个活动使选出他后剩下的资源能尽量多

4.递归贪心算法：

![img](1341696-20180719155347599-1770890486.png)

![img](ContractedBlock.gif) 递归贪心

5.迭代贪心算法：尾递归：以一个对自身的递归调用再接一次并集操作结尾

![img](1341696-20180719155453787-367399759.png)

![img](ContractedBlock.gif) 迭代贪心

 

 三.赫夫曼编码

1.前提：（1）编码（二进制编码）：把字符根据某种策略转换为计算机能识别的二进制形式（2）码字：每个字符用一个唯一的二进制串表示

（3）定长编码：所有字符的二进制编码长度一样（4）变长编码：赋予高频字符短码字，低频字符长码字，一般可达到比定长编码更好的压缩率

（5）前缀码：没有任何码字是其他码字的前缀，用来简化解码，保证达到最优数据压缩率

（6）满二叉树：每个非叶节点都有两个孩子节点

2.赫夫曼编码：通过二叉树的结构，其叶节点为给定的字符，字符的二进制码字用从根节点（最高频字符）到该字符的叶节点的简单路径表示，0转向左孩子，1转向右孩子，最优的编码方式总是对应一棵满二叉树

3.问题描述：设计一个贪心算法来构造最优前缀码

4.赫夫曼算法具有最优子结构和贪心选择性

![img](1341696-20180719221527558-628603117.png)

![img](1341696-20180719221530682-40619510.png)

![img](ContractedBlock.gif) 赫夫曼编码树

 

 

 四.拟阵

1.定义

![img](1341696-20180720092331477-154991050.png)

序偶M：两个具有固定次序的客体组成一个序偶，它常常表达两个客体之间的关系。

I（1）非空族：非空的（子集的集合）（2）遗传性：如果一个集合B属于I，则它的所有子集也属于I

 交换性：在I中，只要一个独立子集不是最大的（元素最多），我们总可以找到比它大一点的独立子集

2.图拟阵：如果图G=（V,E）是一个无向图，那么M(G)=（S(G)，I(G)）是一个拟阵，其中S(G)=E是一个有限集，而且I(G)是它的非空族

3.对于A∈I和一个元素x不∈A，如果A∪{x}属于I，则x是A的一个拓展。如果一个独立子集不存在拓展，则称它是最大的。

4.拟阵中所有最大独立子集都具有相同大小

5.加权拟阵：

![img](1341696-20180720094721450-1612225965.png)

![img](1341696-20180720094733128-1499562447.png)

![img](1341696-20180720101410646-851798497.png)

![img](1341696-20180720101422985-1574239810.png)

![img](ContractedBlock.gif) 拟阵

 

6.拟阵具有贪心选择性质和最优子结构性质 

6.拟阵理论不能完全覆盖所有的贪心算法（如赫夫曼编码问题），但它可以覆盖大多数具有实际意义的情况

 

五.贪心法对比动态规划

1.相同：都利用了最优子结构，都一般用于求解最优化问题

2.不同：

（1）贪心法：第一次选择之前不求解任何子问题；贪心选择后只留下唯一一个子问题；贪心算法进行选择时可能依赖之前作出的选择，但不依赖任何将来的选择或是子问题的解；一般自顶向下迭代求解；原问题最优解就是把子问题最优解和贪心选择组合起来

（2）动态规划：先求解子问题才能进行第一次选择；一次选择后可能有多个子问题；子问题有重叠性；一般自底向上带备忘地递归求解；原问题的最优解是根据计算出的子问题最优解构造出来的

比如：

 ![img](1341696-20180719163606315-1509785221.png)

分析：这两个问题都有最优子结构，但分数背包问题能用贪心法，而0-1背包问题不能，

原因在于0-1问题将一个商品装到背包时，必须比较包含此商品的子问题的解与不包含它的子问题的解，然后才能做出选择，这会导致大量的重叠子问题